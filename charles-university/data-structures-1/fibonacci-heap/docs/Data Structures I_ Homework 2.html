<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0054)https://kam.mff.cuni.cz/~ds1/hw/2-fibheap/problem.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- <link rel=stylesheet title=Default href='../../css/style.css' type='text/css' media=all> -->

<title>Data Structures I: Homework 2</title>

<style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
<body>

<h1>Data Structures I – Homework 1</h1>

<p>
<b>Deadline:</b> November 19, 2017<br>
<b>Submit:</b> by <a href="https://kam.mff.cuni.cz/~ds1/">web form</a><br>
<b>General rules:</b> <a href="https://kam.mff.cuni.cz/~ds1/hw/rules.html">Read them carefully</a>

</p><h2>Problem description</h2>

<p>Implement two versions of Fibonacci heaps, the one presented during the
lecture and a <i>naive</i>&nbsp;version that ignores the flags of nodes, i.e. it
will not perform any cascading cuts:

<img src="./Data Structures I_ Homework 2_files/no_casc.png" alt="Výsledek naivní operace Decrease">

</p><p>Examine the behaviour of these two data structures on test data generated by
the program described below. The test data contains sets of varying sizes with
three kinds of operations:

</p><ul>
<li><em>random test</em>: a sequence in which the number of Insert, DecreaseKey, ExtractMin operations are approximately equally distributed;
</li><li><em>biased test</em>: a sequence in which there are considerable fewer ExtractMin operations than in the random test;
</li><li><i>special test: </i>a sequence to be tested against the naive implementation of the Fibonacci heap.
</li></ul>

<p>Your task is to determine the average number of steps that an ExtractMin
operation takes. The number of steps of one such operation is the number of
children of the deleted node that are appended to the list of trees, plus the
number of times some tree is linked to another tree during the subsequent
consolidation procedure.

</p><h3>Generating the data</h3>

<p>Download&nbsp;<a href="https://kam.mff.cuni.cz/~ds1/hw/2-fibheap/heapgen.cpp" "="">the generator</a> and run it with the following parameters:

</p><ul>
<li><code>-s&nbsp;<em>XX</em></code>, where&nbsp;<em>XX</em>&nbsp;are the last two digits of your student ID;
</li><li><code>-r</code>, to generate the random test;
</li><li><code>-b</code>, to generate the biased test;
</li><li><code>-x</code>, to generate the special test. (Beware: the output has some 68GB,
so you probably don't want to store it to a file; instead, pipe it directly to your program.)
</li></ul>

<p>The output of the generator is a text file. Each line specifies a single operation on the tree:

</p><ul>
<li><code>#&nbsp;<em>N</em></code>: start a test in which&nbsp;<em>N</em> elements need to be stored in a heap&nbsp;– discard the previous heap and create a new one (the set size can be useful for plotting);
</li><li><code>INS&nbsp;<em>E K</em></code>: insert the element <i>E</i> with key&nbsp;<em>K</em>&nbsp;to the heap;
</li><li><code>DEL</code>: delete the element with minimum key (if several elements have the same key, only delete one of them);
</li><li><code>DEC&nbsp;<em>E K</em></code>: decrease the key of element <i>E</i> to key <i>K</i> (if the element <i>E</i> does not exist, or its key is smaller than <i>K</i> already, ignore this operation).
</li></ul>

<p>A single call of the generator creates a sequence of tests with at most 2.000.000 elements each.
The element identifiers <i>E</i>&nbsp;are integers from 0 to <i>N</i>-1. Each identifier is unique, i.e., you can assume that at any time there is at most one element with identifier <i>E</i> stored in the heap. However after an element was deleted, it may be inserted again at a later time. The keys <i>K</i> are not unique, i.e. at any time there may be several elements with the same key stored in the heap. Make sure you have pointers to elements so you have direct access to them during a Decrease operation.

</p><h3>Resulting graphs</h3>

<p>Draw plots showing the dependence of the average number of steps of a ExtractMin operation&nbsp;on the size&nbsp;<em>N</em>.

</p><ol>
<li>A graph showing two plots of the average number of steps of an ExtractMin operation in the proper Fibonacci heap (not the naive version): one plot for the random test and one for the biased test. How do you explain the difference between the plots of the two tests?
</li><li>For the special test, a graph showing two plots of the average number of steps of an ExtractMin operation: one for the proper Fibonacci heap and one for the naive version. Can you tell what approximately the asymptotic growth rate of each plot is?
</li></ol>

<h3>Example input</h3>
<pre><code>#4
INS 0 3
DEC 0 0
DEL
INS 1 2
DEC 1 0
DEL
INS 2 1
DEC 2 0
INS 3 3
# 5
INS 0 3
DEL
DEC 0 0
INS 1 1
DEC 1 0
DEL
INS 2 4
INS 3 4
DEC 3 0
DEC 2 0
DEL
DEL
INS 2 2
</code></pre>



</body></html>