<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0052)https://kam.mff.cuni.cz/~ds1/hw/1-splay/problem.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- <link rel=stylesheet title=Default href='../../css/style.css' type='text/css' media=all> -->

<title>Data Structures I: Homework 1</title>

<style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
<body>

<h1>Data Structures I – Homework 1</h1>

<p>
<b>Deadline:</b> October 29, 2017<br>
<b>Submit:</b> by <a href="https://kam.mff.cuni.cz/~ds1/">web form</a><br>
<b>General rules:</b> <a href="https://kam.mff.cuni.cz/~ds1/hw/rules.html">Read them carefully</a>

</p><h2>Popis problému</h2>

<p>
Implement two versions of Splay trees, the classical one which uses double rotations and a <i>naive</i> version which uses only the simple rotation on the whole path from a splayed node to the root.

<img src="./Data Structures I_ Homework 1_files/single_rot.png" alt="Simple rotation" height="200px">

</p><p>
Examine the behaviour of both data structures on test data generated by the program described below. The test data starts by inserting <em>N</em> elements using operation Insert and then a sequence of operation Find follows. There are two types of such sequences:
</p><ul>
<li><em>uniform subset test</em>: operations Find uniformly searches for a random element from a fixed subset of size <em>T</em> of the inserted items; 
</li><li><em>sequential test</em>: a specific sequence of Find operations. 
</li></ul>
<p>
Your task is to measure the average length of paths from the root to the given splayed node for each test data set.

</p><h3>Generating the data</h3>
<p>
Download the <a href="https://kam.mff.cuni.cz/~ds1/hw/1-splay/splaygen.c">generator</a> and run it with the following parameters: 
</p><ul>
<li><code>-s <em>XX</em></code>, where <em>XX</em> are the last two digits of your student ID;
</li><li><code>-t <em>T</em></code>, where <em>T</em> is the size of the searched subset;
</li><li><code>-l</code>, if you want to ensure that the searched subset is at the end of the insertion sequence;
</li><li><code>-b</code>, if you want to generate the sequential test.
</li></ul>

<p>
The output of the generator is a text file. Each line specifies a single operation on the tree: 
</p><ul>
<li><code># <em>N</em> </code>: start a test for a set of size <em>N</em> – discard the previous tree and create a new one (the set size can be useful for plotting);
</li><li><code>I <em>X</em></code>: insert a key <em>X</em> to the tree (if the key is already present, ignore this operation);
</li><li><code>F <em>X</em></code>: search a key X in the tree.
</li></ul>
<p>
A single call of the generator creates a sequence of tests ranging roughly from 1.000 to 1.000.000 elements.

</p><h3>Resulting graphs</h3>
<p>
For each of the two tests, draw a plot showing the dependence of the average path length of operation find on the size <em>N</em>:
</p><ol>
<li>For the classical Splay tree and uniform subset test, plot six curves, each for one value of <em>T</em> in {10, 100, 1000, 10000, 100000, 1000000}.
</li><li>As the previous graph, but using the naive implementation of Splay trees.
</li><li>Joint plot of the first and the second plots containing three curves for the classical and another three curves for the naive version for values  <em>T</em> in {100, 10000, 1000000}.
</li><li>For the classical and naive version, plot the average lengths of the paths during the sequential test.
</li></ol>
<p>
Explain the shape of all curves and discuss differences of behaviour of both versions of trees.

</p><h3>Example input</h3>
<pre># 3
I 1
I 2
I 0
F 1
F 0
F 2
# 4
I 2
I 3
I 0
I 1
F 2
F 0
F 2
F 3
</pre>

<h3>Notes</h3>

<p>
It may not be clear when the argument <code>-l</code> of the generator may be useful. Well, try to use it and observe its influence. It may help you to understand measured results.

</p><p>
Every test runs at most 6 minutes on our computer. If our program needs more than an hour, then try to find a better solution.



</p></body></html>